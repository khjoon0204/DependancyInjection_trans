# DependancyInjection_trans
위키백과의 Dependency injection 번역


소프트웨어공학에서, 의존주입(dependency injection)은 한 객체가 다른 객체에 의존할 때 쓰이는 기술이다. "의존"은 [서비스](http:// "소프트웨어설계 관점에서, 서비스에 기반한 설계. 서비스란 서로다른 목적을 가진 클라이언트들이 사용할 수 있는 기능 또는 그 기능의 모음이다, 사용량은 제한가능 해야함.")의 예로 사용될 수 있다. 클라이언트가 어떤 서비스를 사용할지 정하는 대신에, 클라이언트에게 무슨 서비스를 사용할지 묻는다. "의존"은 그 의존성(서비스)을 사용할 객체([클라이언트](http:// "클라이언트는 서버에서 제공하는 서비스에 접근하는 컴퓨터 하드웨어 또는 소프트웨어이다. 서버는 클라이언트가 네트워크를 통해 서비스에 접근할 경우 또다른 하나의 컴퓨터일 수 있다."))에게 넘기는 것을 말한다. 서비스는 클라이언트의 [상태](http:// "information technology and computer science 에서 시스템은 상태값이 있는 것으로 묘사된다. 만약 유저 상호작용 또는 선진행된 이벤트를 기억하도록 설계했다면, 기억한 정보를 시스템상태값이라 부른다")의 한 부분이다. 클라이언트가 [서비스를 찾고](http:// "service locator pattern 은 하나의 디자인 패턴이고, 소프트웨어개발에서는 안티패턴이다. 서비스를 가져오는 과정을 추상화 레이어에 캡슐화하기 때문이다. 이 패턴은 요청이 있을 때 작업에 필요한 정보를 받는,  service locator 라고 알려져있다. 서비스를 찾는 것에 대한 가장 큰 비판은 의존관계를 감춘다는 것이다.") 빌드하는 대신 사용할 서비스들을 클라이언트에게 제공하는 것이 이 패턴의 기본개념이다.  

의존주입의 의도는 객체를 사용하거나 생성할 때 [Separation of Concerns](http:// "컴퓨터이론에서, Soc(separation of concertns)는 프로그램을 섹션별로 나누는 방식에 대한 설계입니다. 그 대상은 프로그램 코드에 대한 것이고, 정확히는 시작할 클래스의 이름 입니다. Soc를 잘 구현한 프로그램을 모듈화된 프로그램이라 부릅니다. 모듈화 즉 클래스 분리는 잘 정의된 인터페이스 내에 캡슐화함으로써 이루어집니다. 캡슐화는 정보를 숨기는 것을 의미합니다. 계층화된 설계는 시스템정보에서 클래스 분리의 한 예이기도 합니다.")
를 이루는 것이다. 이것은 가독성과 코드 재사용성을 높일 수 있다.

의존주입은 inversion of control 기술의 한 형태이다. 서비스들을 호출하는 클라이언트는 어떻게 그 서비스들이 생성되는지 알지 못합니다. 대신에, delegate 에 서비스를 제공할 코드 또는 injector를 제공합니다. 클라이언트는 injector 를 호출하지 못합니다; 서비스를 생성하는 injector를. injector는 이미 있거나 injector에 의해 생성된 서비스를 클라이언트에게 주입합니다. 그런 후에야 클라이언트는 서비스들을 이용합니다. 클라이언트는 injector 에 대해, 어떻게 서비스를 생성하는지 실제로 어떤 서비스가 사용되는지 따위를 알 필요가 없습니다. 클라이언트는 오직 서비스 인터페이스에 대해서만 알면 됩니다. 인터페이스에 클라이언트가 서비스를 어떻게 사용할지 정의되어 있기 때문입니다. 이것은 , 객체 "생성"의 책임으로 부터 "사용"의 책임을 분리합니다.

### Intent
의존주입은 다음과 같은 문제를 해결합니다.
* 어떻게 어플리케이션이나 클래스가 그것들의 객체 생성으로 부터 자유로울 수 있는가?
* 어떻게 서로다른 환경내에서 객체 생성 방법을 지정할 수 있는가?
* 어떻게 어플리케이션이 서로다른 환경을 지원할 수 있는가?

클래스 내에서 직접 객체들을 생성하는 것은 융통성이 없습니다. 왜냐하면 나중에 클래스와 떨어져서 생성할 수 없기 때문입니다. 다른 객체가 필요할 때 클래스를 재사용할 수 없고 테스트하기도 어렵게 만듭니다. 실제 데이터를 mock 객체로 대체할 수 없기 때문입니다. 

클래스는 더이상 객체가 필요할 때 그것을 생성할 책임을 가지지 않고, Abstract Factory 디자인 패턴과 같이 팩토리객체에 생성을 위임할 필요도 없습니다.

### Overview
의존주입은 클라이언트의 의존성 생성을 행위로 부터 분리합니다. 이것은 프로그램이 loosely coupled 될 수 있고, dependency inversion 과 single responsibility principles 를 따를 수 있게 됩니다. service locator pattern 과는 완전히 반대로 클라이언트가 시스템이 어떤 의존성을 찾는지 알게 됩니다.

기초적인 단위의 주입은 새로운 것이거나 특정한 메카니즘이 아닙니다. parameter passing 방식으로 모두 똑같이 작동합니다. 주입에서 paramter passing 은 클라이언트가 세부단계까지 관여할 필요가 없음을 말합니다.

주입은 또한 제어를 넘기는 것에 관한 것이고, 어떻게 독립적으로 이전할 것인지에 관한 것입니다, 참조 위치든 값이든 말이죠.

의존주입은 다음의 네가지 원칙을 따릅니다.
* service 객체 필요
* service 에 의존하는 client 객체 필요
* client 가 어떻게 서비스를 사용할지 정의된 interfaces
* 주입기(injector), 서비스를 생성하고 클라이언트에게 주입할 책임이 있는.

비유하자면,
* service - 전기, 가스, 하이브리드 또는 디젤 차
* client - 엔진에 상관없이 같은 방식으로 차를 운전하는 운전자
* interface - automatic방식, 운전자가 기어나 기타 엔진상세에 대해 이해하고 있을 필요가 없는.
* injector - 차를 사주고, 어떤 종류를 살지 결정하는 부모님

어떤 객체든 service 가 될 수 있다. 다른 객체를 이용하는 어떤 객체든 client 가 될 수 있다. 무슨 이름으로 하든 상관 없고 주입에서 어떤 역할을 하는지가 중요하다.

interfaces 는 클라이언트가 의존하는 타입이다. 클라이언트가 사용가능한 것이다. interface 는 서비스에 의해 구현된 말그대로의 interface 일 수도 있지만, 추상 클래스일 수도 있고 심지어 그 자체가 서비스 일 수도 있다, 마지막은 [DIP](http:// "dependency inversion principle") 를 위반하고 테스트하기 어려워지지만. 한가지 알아야할 것은, 클라이언트가 인터페이스가 어디에 있는지 모르기 때문에 인터페이스를 구체적으로 생성하거나 확장하지 말아야 한다. 

클라이언트는 인터페이스에 대한 구체적인 구현은 알지 못한다. 오직 아는 것은 인터페이스 이름과 API 이다. 클라이언트는 인터페이스가 무엇을 바꾸는지 알지 못해도 인터페이스를 바꿀 필요가 없다. 그러나 인터페이스가 클래스에서 인터페이스나 그 외의 것으로 refactoring 될 때에는 다시 컴파일 할 필요는 있다.(https://softwareengineering.stackexchange.com/q/257976). 만약 클라이언트와 서비스가 따로 배포되면 문제가 어렵다, 의존주입이 해결할 수 없는 관계이기 때문이다.

injector 는 클라이언트에게 서비스를 소개한다. 또는 종종 클라이언트를 만들기도 한다. injector 는 객체를 클라이언트화 하거나 나중에 다른 클라이언트를 위한 서비스로 다루면서 복잡한 객체간 관계를 가지기도 합니다. injector 는 클라이언트가 아닌 단지 서로 일하는 많은 객체들 일 수 있습니다. injector 는 다음과 같이 불리기도 합니다: assembler, provider, container, factory, builder, spring, construnction code 또는 main.

의존성주입은 규칙이 될 수도 있다, 모든 객체의 생성과 행위를 분리토록 요구하는. 객체 생성을 수행하는 DI 프레임워크 따르면 new 키워드 사용을 금지하거나 또는 덜 엄격하게, 오직 [value objects](http:// "컴퓨터이론에서, value object 는 작은 객체이다, 동일여부는 같은 값을 가질 때이고, 같은 객체이어야 함을 의미하지는 않는. ") 생성만 허락할 수 있다.

### Taxonomy
Inversion of control(IoC) 는 DI 보다 일반적이다. 간단히 말해, IoC 는 당신이 코드를 호출 하는 것이 아닌, 코드가 당신을 호출하게끔 하는것이다. [template method pattern](http:// "객체지향 프로그래밍에서, template method 는 Design Patterns 책에서 나오는 행위설계패턴중 하나 입니다. template method 는 추상화된 superclass 에 있는 메소드입니다. template method 로써 같은 파일내에 추가적인 helper mothod들을 구현합니다. ") 이  DI 뺀 IoC 이다. polymorphism 은 상속을 통해 이루어진다. 

[composition]( "컴퓨터이론에서 object composition 은 객체나 데이터타입을 더 복잡한 하나로 조합하는 방법을 말한다. 조합(Compositions)은 데이터구조와 다음의 공통적인 것들과 관련이 있습니다: union, set, sequence 그리고 다양한 graph구조. 객체지향에서 사용하는 객체들과 마찬가지로." ) 을 통해 IoC를 구현하는 의존성주입은 [strategy pattern]() 과 동일할 수 있지만 strategy pattern 은 객체의 생명주기를 통해 객체간 서로 주고받을 수 있는 의존성을 목표로합니다, 의존성주입은 의존성에 대해 오직 하나의 인스턴스만 갖습니다. delegation 과 composition 을 통해서지만 여전히 polymorphism 입니다.















