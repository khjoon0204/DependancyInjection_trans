# DependancyInjection_trans
위키백과의 Dependency injection 번역


소프트웨어공학에서, 의존주입(dependency injection)은 한 객체가 다른 객체에 의존할 때 쓰이는 기술이다. "의존"은 [서비스](http:// "소프트웨어설계 관점에서, 서비스에 기반한 설계. 서비스란 서로다른 목적을 가진 클라이언트들이 사용할 수 있는 기능 또는 그 기능의 모음이다, 사용량은 제한가능 해야함.")의 예로 사용될 수 있다. 클라이언트가 어떤 서비스를 사용할지 정하는 대신에, 클라이언트에게 무슨 서비스를 사용할지 묻는다. "의존"은 그 의존성(서비스)을 사용할 객체([클라이언트](http:// "클라이언트는 서버에서 제공하는 서비스에 접근하는 컴퓨터 하드웨어 또는 소프트웨어이다. 서버는 클라이언트가 네트워크를 통해 서비스에 접근할 경우 또다른 하나의 컴퓨터일 수 있다."))에게 넘기는 것을 말한다. 서비스는 클라이언트의 [상태](http:// "information technology and computer science 에서 시스템은 상태값이 있는 것으로 묘사된다. 만약 유저 상호작용 또는 선진행된 이벤트를 기억하도록 설계했다면, 기억한 정보를 시스템상태값이라 부른다")의 한 부분이다. 클라이언트가 [서비스를 찾고](http:// "service locator pattern 은 하나의 디자인 패턴이고, 소프트웨어개발에서는 안티패턴이다. 서비스를 가져오는 과정을 추상화 레이어에 캡슐화하기 때문이다. 이 패턴은 요청이 있을 때 작업에 필요한 정보를 받는,  service locator 라고 알려져있다. 서비스를 찾는 것에 대한 가장 큰 비판은 의존관계를 감춘다는 것이다.") 빌드하는 대신 사용할 서비스들을 클라이언트에게 제공하는 것이 이 패턴의 기본개념이다.  

의존주입의 의도는 객체를 사용하거나 생성할 때 [Separation of Concerns](http:// "컴퓨터이론에서, Soc(separation of concertns)는 프로그램을 섹션별로 나누는 방식에 대한 설계입니다. 그 대상은 프로그램 코드에 대한 것이고, 정확히는 시작할 클래스의 이름 입니다. Soc를 잘 구현한 프로그램을 모듈화된 프로그램이라 부릅니다. 모듈화 즉 클래스 분리는 잘 정의된 인터페이스 내에 캡슐화함으로써 이루어집니다. 캡슐화는 정보를 숨기는 것을 의미합니다. 계층화된 설계는 시스템정보에서 클래스 분리의 한 예이기도 합니다.")
를 이루는 것이다. 이것은 가독성과 코드 재사용성을 높일 수 있다.

의존주입은 inversion of control 기술의 한 형태이다. 서비스들을 호출하는 클라이언트는 어떻게 그 서비스들이 생성되는지 알지 못합니다. 대신에, delegate 에 서비스를 제공할 코드 또는 injector를 제공합니다. 클라이언트는 injector 를 호출하지 못합니다; 서비스를 생성하는 injector를. injector는 이미 있거나 injector에 의해 생성된 서비스를 클라이언트에게 주입합니다. 그런 후에야 클라이언트는 서비스들을 이용합니다. 클라이언트는 injector 에 대해, 어떻게 서비스를 생성하는지 실제로 어떤 서비스가 사용되는지 따위를 알 필요가 없습니다. 클라이언트는 오직 서비스 인터페이스에 대해서만 알면 됩니다. 인터페이스에 클라이언트가 서비스를 어떻게 사용할지 정의되어 있기 때문입니다. 이것은 , 객체 "생성"의 책임으로 부터 "사용"의 책임을 분리합니다.

### Intent
의존주입은 다음과 같은 문제를 해결합니다.
* 어떻게 어플리케이션이나 클래스가 그것들의 객체 생성으로 부터 자유로울 수 있는가?
* 어떻게 서로다른 환경내에서 객체 생성 방법을 지정할 수 있는가?
* 어떻게 어플리케이션이 서로다른 환경을 지원할 수 있는가?

클래스 내에서 직접 객체들을 생성하는 것은 융통성이 없습니다. 왜냐하면 나중에 클래스와 떨어져서 생성할 수 없기 때문입니다. 다른 객체가 필요할 때 클래스를 재사용할 수 없고 테스트하기도 어렵게 만듭니다. 실제 데이터를 mock 객체로 대체할 수 없기 때문입니다. 

클래스는 더이상 객체가 필요할 때 그것을 생성할 책임을 가지지 않고, Abstract Factory 디자인 패턴과 같이 팩토리객체에 생성을 위임할 필요도 없습니다.

### Overview
의존주입은 클라이언트의 의존성 생성을 행위로 부터 분리합니다. 이것은 프로그램이 loosely coupled 될 수 있고, dependency inversion 과 single responsibility principles 를 따를 수 있게 됩니다. service locator pattern 과는 완전히 반대로 클라이언트가 시스템이 어떤 의존성을 찾는지 알게 됩니다.

기초적인 단위의 주입은 새로운 것이거나 특정한 메카니즘이 아닙니다. parameter passing 방식으로 모두 똑같이 작동합니다. 주입에서 paramter passing 은 클라이언트가 세부단계까지 관여할 필요가 없음을 말합니다.



















